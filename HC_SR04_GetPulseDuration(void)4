uint32_t HC_SR04_GetPulseDuration(void) {
    uint32_t timeout = 1000000; // Increased timeout
    uint32_t start_time = 0, end_time = 0;
    uint8_t got_rising_edge = 0;
    
    // Wait for ECHO to be LOW (ensure clean start)
    timeout = 100000;
    while (HAL_GPIO_ReadPin(HC_SR04_ECHO_GPIO_Port, HC_SR04_ECHO_Pin) == GPIO_PIN_SET) {
        if (timeout-- == 0) {
            printf("Timeout: ECHO stuck HIGH\r\n");
            return 0;
        }
    }
    
    // Wait for rising edge (start of pulse)
    timeout = 100000;
    while (HAL_GPIO_ReadPin(HC_SR04_ECHO_GPIO_Port, HC_SR04_ECHO_Pin) == GPIO_PIN_RESET) {
        if (timeout-- == 0) {
            printf("Timeout: No rising edge\r\n");
            return 0;
        }
    }
    start_time = Get_Micros();
    
    // Wait for falling edge (end of pulse)
    timeout = 100000;
    while (HAL_GPIO_ReadPin(HC_SR04_ECHO_GPIO_Port, HC_SR04_ECHO_Pin) == GPIO_PIN_SET) {
        if (timeout-- == 0) {
            printf("Timeout: No falling edge\r\n");
            return 0;
        }
    }
    end_time = Get_Micros();
    
    // Calculate duration (handle timer overflow)
    uint32_t pulse_duration;
    if (end_time >= start_time) {
        pulse_duration = end_time - start_time;
    } else {
        pulse_duration = (0xFFFF - start_time) + end_time;
    }
    
    // Validate pulse duration (58us to 38ms for 1cm to 6.5m)
    if (pulse_duration < 58 || pulse_duration > 38000) {
        printf("Invalid pulse: %lu us\r\n", pulse_duration);
        return 0;
    }
    
    return pulse_duration;
}
